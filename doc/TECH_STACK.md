# 기술 스택 선택 가이드

백테스팅 시스템에서 채택한 기술 스택들의 선택 이유와 배경을 설명합니다.

## 목차
- [전체 아키텍처 원칙](#전체-아키텍처-원칙)
- [프론트엔드 기술 스택](#프론트엔드-기술-스택)
- [백엔드 기술 스택](#백엔드-기술-스택)
- [데이터베이스 및 캐시](#데이터베이스-및-캐시)
- [빌드 및 배포](#빌드-및-배포)
- [외부 API 및 라이브러리](#외부-api-및-라이브러리)

## 전체 아키텍처 원칙

### 마이크로서비스 지향 설계
- **원칙**: 프론트엔드와 백엔드를 완전히 분리하여 독립적 개발과 배포 가능
- **장점**: 
  - 개발팀 분업 효율성 극대화
  - 각 서비스별 독립적 스케일링
  - 기술 스택 변경 시 영향 범위 최소화
- **구현**: Docker 컨테이너 기반 분리, RESTful API 통신

### 성능 우선 설계
- **원칙**: 금융 데이터 처리의 실시간성과 정확성 보장
- **전략**: 
  - 캐시 레이어를 통한 API 호출 최적화
  - 클라이언트 사이드 렌더링으로 서버 부하 분산
  - 비동기 처리를 통한 사용자 경험 개선

### 개발 생산성 중심
- **원칙**: 빠른 개발과 안전한 배포를 위한 도구 선택
- **전략**: 
  - 타입 안전성 보장 (TypeScript, Pydantic)
  - 자동화된 테스트와 CI/CD
  - 핫 리로드 지원으로 개발 효율성 증대

## 프론트엔드 기술 스택

### React 18 선택 이유
**채택 배경**: 복잡한 금융 데이터 시각화와 실시간 업데이트 요구사항

**주요 이유**:
1. **컴포넌트 재사용성**: 차트, 폼, 테이블 등 UI 컴포넌트의 모듈화 용이
2. **생태계 성숙도**: 차트 라이브러리(Recharts), UI 프레임워크(Bootstrap) 풍부
3. **개발자 친화성**: 널리 사용되는 기술로 유지보수성 확보
4. **성능 최적화**: Virtual DOM을 통한 효율적 렌더링

**대안 기술 대비 장점**:
- Vue.js 대비: 더 큰 생태계와 금융 차트 라이브러리 지원
- Angular 대비: 더 가벼운 러닝 커브와 빠른 개발 속도
- Vanilla JS 대비: 컴포넌트 관리와 상태 관리의 복잡성 해결

### TypeScript 채택 이유
**채택 배경**: 금융 데이터의 정확성과 API 연동의 타입 안전성 필요

**주요 이유**:
1. **타입 안전성**: 런타임 오류 사전 방지, 특히 숫자 계산 오류 차단
2. **개발 경험 향상**: IDE 자동완성, 리팩토링 지원
3. **API 인터페이스 명시**: 백엔드와의 계약 명확화
4. **유지보수성**: 코드 의도 명확화로 장기 프로젝트 관리 용이

### Vite 빌드 도구 선택
**채택 배경**: 개발 생산성과 빌드 성능 최적화 필요

**주요 이유**:
1. **개발 서버 속도**: ESBuild 기반으로 Create React App 대비 10-100배 빠른 핫 리로드
2. **번들 최적화**: Rollup 기반으로 최적화된 프로덕션 빌드
3. **설정 간소화**: Zero-config에 가까운 설정으로 개발 집중도 향상
4. **모던 기술 지원**: ES6 모듈, TypeScript 네이티브 지원

**Create React App 대비 장점**:
- 개발 서버 시작 시간: 5-10초 → 1-2초
- 핫 리로드 속도: 3-5초 → 0.1-0.5초
- 빌드 시간: 1-2분 → 10-30초

### React Bootstrap 채택 이유
**채택 배경**: 빠른 UI 개발과 반응형 디자인 구현 필요

**주요 이유**:
1. **개발 속도**: 사전 제작된 컴포넌트로 빠른 프로토타이핑
2. **디자인 일관성**: Bootstrap 기반의 통일된 디자인 시스템
3. **접근성**: ARIA 지원으로 웹 접근성 기준 충족
4. **반응형 디자인**: 모바일/데스크톱 동시 지원

**대안 라이브러리 대비**:
- Material-UI 대비: 더 가벼운 번들 사이즈, 커스터마이징 용이성
- Ant Design 대비: 서구권 디자인 친화성, 학습 비용 절감
- CSS Framework 없음 대비: 개발 시간 단축, 일관성 보장

### Recharts 차트 라이브러리 선택
**채택 배경**: 금융 데이터 시각화의 복잡성과 상호작용성 요구

**주요 이유**:
1. **React 네이티브**: React 컴포넌트 기반으로 상태 관리 통합 용이
2. **선언적 API**: JSX 문법으로 직관적인 차트 구성
3. **커스터마이징**: 금융 차트 특화 기능(OHLC, 거래량 등) 구현 가능
4. **성능 최적화**: SVG 기반으로 확대/축소 시 화질 손실 없음

**Chart.js/D3.js 대비 장점**:
- Chart.js 대비: React 생태계 통합, 더 나은 타입스크립트 지원
- D3.js 대비: 더 간단한 API, React와의 라이프사이클 충돌 방지
- 차트 라이브러리 없음 대비: 개발 시간 대폭 단축, 검증된 차트 로직

## 백엔드 기술 스택

### FastAPI 프레임워크 선택
**채택 배경**: 고성능 API 서버와 자동 문서화 필요

**주요 이유**:
1. **성능**: ASGI 기반으로 Node.js 수준의 높은 성능
2. **자동 문서화**: OpenAPI/Swagger 자동 생성으로 API 문서 관리 효율성
3. **타입 힌트 네이티브 지원**: Python 타입 힌트 기반 자동 검증
4. **모던 Python 기능**: async/await, 타입 힌트 등 최신 Python 기능 활용

**Django/Flask 대비 장점**:
- Django 대비: 더 가벼운 구조, API 중심 설계, 높은 성능
- Flask 대비: 내장 검증/문서화, 비동기 지원, 타입 안전성
- Express.js 대비: 더 강력한 타입 시스템, 자동 검증

### Pydantic V2 데이터 검증
**채택 배경**: 금융 데이터의 정확성과 API 인터페이스 신뢰성 보장

**주요 이용**:
1. **강력한 검증**: 런타임 데이터 검증으로 잘못된 입력 차단
2. **자동 직렬화**: JSON 변환 과정에서 타입 안전성 보장
3. **성능 최적화**: V2에서 Rust 기반 코어로 검증 성능 대폭 향상
4. **개발자 경험**: IDE 자동완성과 타입 체크 지원

**Marshmallow/Cerberus 대비**:
- 더 빠른 성능 (V2 기준 5-50배)
- FastAPI와의 완벽한 통합
- 더 직관적인 API 설계

### backtesting.py 라이브러리 채택
**채택 배경**: 금융 백테스팅의 복잡한 로직을 검증된 라이브러리로 해결

**주요 이유**:
1. **검증된 알고리즘**: 수년간 검증된 백테스팅 로직과 성과 지표
2. **확장성**: 사용자 정의 전략 구현 가능한 유연한 아키텍처
3. **성능**: 벡터화된 계산으로 대용량 데이터 처리 최적화
4. **표준 호환**: 업계 표준 성과 지표 (샤프 비율, 최대 낙폭 등) 지원

**자체 구현 대비 장점**:
- 개발 시간 90% 이상 단축
- 금융 수학적 정확성 보장
- 엣지 케이스 처리 완료
- 지속적인 커뮤니티 업데이트

## 데이터베이스 및 캐시

### MySQL 캐시 시스템
**채택 배경**: yfinance API 호출 최적화와 데이터 일관성 보장

**주요 이유**:
1. **API 비용 절감**: 동일 요청에 대한 중복 호출 방지
2. **응답 속도 향상**: 캐시된 데이터 사용으로 2-10배 빠른 응답
3. **안정성**: 외부 API 장애 시 캐시된 데이터로 서비스 연속성 보장
4. **관계형 구조**: 종목, 날짜, 가격 데이터 간의 관계 명확화

**Redis 대비 MySQL 선택 이유**:
- 영구 저장: 서버 재시작 시에도 캐시 유지
- 복잡한 쿼리: 날짜 범위, 종목별 필터링 등 SQL 활용
- 관리 편의성: 백업, 복구, 모니터링 도구 성숙도

### yfinance API 연동
**채택 배경**: 실시간 주식 데이터 확보와 비용 효율성

**주요 이유**:
1. **무료 데이터**: Yahoo Finance 기반으로 별도 API 비용 없음
2. **광범위한 커버리지**: 미국, 한국 주식 및 환율 데이터 포함
3. **Python 생태계 호환**: pandas DataFrame 형태로 데이터 처리 최적화
4. **실시간성**: 일일 업데이트되는 최신 가격 정보

**Bloomberg API/Alpha Vantage 대비**:
- 비용: 무료 vs 월 수십-수백 달러
- 접근성: 간단한 설치 vs 복잡한 인증 과정
- 데이터 품질: 개인/소규모 프로젝트에 충분한 수준

## 빌드 및 배포

### Docker 컨테이너화
**채택 배경**: 개발/운영 환경 일관성과 배포 신뢰성 확보

**주요 이유**:
1. **환경 일관성**: "내 컴퓨터에서는 됐는데" 문제 완전 해결
2. **배포 간소화**: 이미지 빌드 한 번으로 어디서든 실행 가능
3. **리소스 효율성**: VM 대비 가벼운 리소스 사용량
4. **개발 생산성**: 로컬 환경 설정 시간 대폭 단축

**VM/직접 설치 대비**:
- 설정 시간: 수시간 → 수분
- 환경 차이 문제: 완전 해결
- 리소스 사용량: 30-50% 절약

### Docker Compose 오케스트레이션
**채택 배경**: 다중 서비스 개발 환경의 복잡성 관리

**주요 이유**:
1. **서비스 간 네트워킹**: 자동 DNS 해석으로 서비스 디스커버리
2. **환경별 설정**: dev/prod 환경별 다른 설정 파일 사용
3. **종속성 관리**: 서비스 시작 순서와 종속성 자동 처리
4. **볼륨 관리**: 개발 시 코드 변경 즉시 반영

**Kubernetes 대비 선택 이유**:
- 복잡성: 소규모 프로젝트에 적합한 수준
- 학습 곡선: 더 간단한 설정과 디버깅
- 리소스 요구사항: 로컬 개발에 적합

### Jenkins CI/CD 파이프라인
**채택 배경**: 자동화된 테스트와 배포로 코드 품질 보장

**주요 이유**:
1. **품질 게이트**: 테스트 실패 시 배포 자동 중단
2. **일관된 배포**: 수동 배포 실수 방지
3. **병렬 처리**: 프론트엔드/백엔드 테스트 동시 실행
4. **롤백 지원**: 배포 실패 시 이전 버전으로 자동 복구

**GitHub Actions 대비 Jenkins**:
- 온프레미스 제어: 민감한 데이터 외부 노출 방지
- 커스터마이징: 복잡한 빌드 로직 구현 용이
- 비용: 무료 사용량 제한 없음

## 외부 API 및 라이브러리

### 네이버 뉴스 API
**채택 배경**: 주가 변동과 관련된 뉴스 컨텍스트 제공

**주요 이유**:
1. **한국어 뉴스**: 한국 투자자를 위한 현지화된 정보
2. **안정성**: 네이버의 안정적인 API 서비스
3. **검색 품질**: 관련성 높은 뉴스 필터링 기능
4. **비용 효율성**: 합리적인 API 사용 비용

**Google News API 대비**:
- 한국어 컨텐츠 품질 우수
- 기업명 매핑 정확도 높음
- 국내 증권사 리포트 포함

### 개발 도구 및 유틸리티

#### pytest 테스트 프레임워크
**선택 이유**:
- 간결한 문법과 풍부한 플러그인 생태계
- Mock 객체와 픽스처 지원으로 복잡한 테스트 시나리오 구현
- FastAPI와의 완벽한 통합

#### Vitest 프론트엔드 테스트
**선택 이유**:
- Vite와의 네이티브 통합으로 설정 복잡성 제거
- Jest 호환 API로 기존 지식 활용 가능
- ES 모듈 네이티브 지원으로 빠른 테스트 실행

## 기술 스택 결정 과정

### 의사결정 기준
1. **프로젝트 요구사항 적합성** (가중치 40%)
   - 금융 데이터 처리 정확성
   - 실시간 차트 업데이트 성능
   - API 응답 속도

2. **개발 생산성** (가중치 30%)
   - 러닝 커브
   - 개발 도구 지원
   - 디버깅 편의성

3. **장기 유지보수성** (가중치 20%)
   - 커뮤니티 활성도
   - 문서화 품질
   - 업데이트 주기

4. **비용 효율성** (가중치 10%)
   - 라이선스 비용
   - 인프라 비용
   - 학습 비용

### 기술 선택 프로세스
1. **요구사항 분석**: 기능적/비기능적 요구사항 명세
2. **후보 기술 리스트업**: 각 계층별 3-5개 후보 기술 선정
3. **POC 구현**: 핵심 기능 프로토타입으로 기술 검증
4. **성능 벤치마크**: 실제 데이터로 성능 측정
5. **팀 역량 고려**: 개발팀의 기존 경험과 학습 가능성
6. **최종 의사결정**: 정량적/정성적 평가를 종합한 선택

이러한 체계적인 과정을 통해 프로젝트 목표에 최적화된 기술 스택을 구성했습니다.
